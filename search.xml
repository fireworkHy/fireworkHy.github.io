<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>无法将“vue”项识别为 cmdlet、函数、脚本文件或可运行程序的名称</title>
    <url>/2020/10/17/vue%E6%97%A0%E6%95%88%E6%8C%87%E4%BB%A4/</url>
    <content><![CDATA[<blockquote>
<p>配置安装vue-cli后，创建项目时遇上的问题。各种奇技淫巧都没用，最后在网上找着，记录一下。</p>
</blockquote>
<h2 id="状况"><a href="#状况" class="headerlink" title="状况"></a>状况</h2><p>如果在使用 vue 命令的时候提示：</p>
<blockquote>
<p>vue : 无法将“vue”项识别为 cmdlet、函数、脚本文件或可运行程序的名称。请检查名称的拼写，如果包括路径，请确保路径正确，然后再试一次。</p>
</blockquote>
<p>或者</p>
<blockquote>
<p>vue不是内部或外部命令…</p>
</blockquote>
<p>表示系统没有找到 vue.cmd 的地址，需要将地址加入到环境变量。</p>
<p>是的，接下来解决方案就是将它所属目录添加到环境变量中</p>
<h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>搜索vue.cmd，跳到它的目录中，复制它的目录路径，将其添加到环境变量中。</p>
<h2 id="OK-白白😋"><a href="#OK-白白😋" class="headerlink" title="OK~      白白😋"></a>OK~      白白😋</h2>]]></content>
  </entry>
  <entry>
    <title>重拾JS(二)--浅谈装饰器decorator</title>
    <url>/2020/11/14/%E9%87%8D%E6%8B%BEJS%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<h1 id="重拾JS-二-–浅谈装饰器decorator"><a href="#重拾JS-二-–浅谈装饰器decorator" class="headerlink" title="重拾JS(二)–浅谈装饰器decorator"></a>重拾JS(二)–浅谈装饰器decorator</h1><blockquote>
<p>装饰器这个概念应该是从Python那边抄过来的，正如其名，它可以对一些对象进行装饰，然后返回一个新的对象。</p>
</blockquote>
<h2 id="略览"><a href="#略览" class="headerlink" title="略览"></a>略览</h2><ul>
<li>python中：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在python中装饰器的使用</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decorator</span>(<span class="params">func</span>):</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">inner_func</span>(<span class="params">arg</span>):</span></span><br><span class="line">    print(<span class="string">&#x27;inner_func&#x27;</span> + func(arg))</span><br><span class="line">  <span class="keyword">return</span> inner_func</span><br><span class="line"></span><br><span class="line"><span class="meta">@decorator</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">common_func</span>(<span class="params">arg</span>):</span></span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;the arg from common func&#x27;</span> + arg</span><br><span class="line"></span><br><span class="line">common_func(<span class="string">&#x27;the arguments&#x27;</span>)</span><br><span class="line"><span class="comment"># inner_functhe arg from common functhe arguments</span></span><br></pre></td></tr></table></figure>

<ul>
<li>JS中：</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">@decoratorTheClass</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  @decoratorTheProperty())</span><br><span class="line">  method() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>上面的decoratorTheClass以及decoratorTheProperty就是JS中的实例装饰器。</p>
<p>二者在使用上非常相似。上述例子通过<code>@</code>来使用装饰器。一共用了两种：一个用在类上，一个用在方法上。</p>
<p>JS中的装饰器是在ES7中的，它依赖于ES5中的<code>Object.defineProperty</code>这个API。</p>
<h2 id="Object-defineProperty"><a href="#Object-defineProperty" class="headerlink" title="Object.defineProperty"></a><code>Object.defineProperty</code></h2><p><code>Object.defineProperty</code>所做的事情就是，<strong>为一个对象增加新的属性，或者更改对象某个已存在的属性。</strong>调用方式是<code>Object.defineProperty(targetObj, prop, descriptor)</code>，这 3 个参数分别代表：</p>
<ul>
<li><p><code>targetObj</code>:要处理的对象</p>
</li>
<li><p><code>prop</code>:要定义或修改的属性</p>
</li>
<li><p><code>descriptor</code>:将被定义或修改的属性描述符</p>
</li>
</ul>
<p>有意思的是<code>descriptor</code> 参数，它其实也是一个对象，其字段决定了 <code>targetObj</code>的<code>prop</code> 属性的一些特性。比如<code> enumerable</code> 的真假就能决定目标对象是否可枚举…这些属性。</p>
<h3 id="descriptor"><a href="#descriptor" class="headerlink" title="descriptor"></a><code>descriptor</code></h3><blockquote>
<p>属性描述</p>
</blockquote>
<p>定义的对象中，每一个属性都有一个属性描述对象，用来描述该属性的基本特性。</p>
<p>目前有两种属性描述符：</p>
<ul>
<li><strong>数据描述符</strong>：一个具有值的属性。该值会设置是否可被重写。</li>
<li><strong>存取描述符</strong>：由<code>getter-setter</code>函数对描述的属性。</li>
</ul>
<blockquote>
<p> 属性描述符必须是这两种形式之一, 两种形式不共存。</p>
</blockquote>
<h2 id="Decorator在class中使用"><a href="#Decorator在class中使用" class="headerlink" title="@Decorator在class中使用"></a>@Decorator在class中使用</h2><blockquote>
<p>装饰器可以用来装饰整个类。</p>
</blockquote>
<h3 id="新增属性"><a href="#新增属性" class="headerlink" title="新增属性"></a>新增属性</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">@name</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">name</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">  target.name = <span class="string">&quot;猫猫&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 显示&quot;猫猫&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(Cat.name)</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>@testable</code> 就是一个装饰器。它修改 <code>MyTestableClass</code> 这个类的属性，为它加上了静态属性 <code>isTestable</code>。<code>testable</code> 函数的参数 <code>target</code>是 <code>MyTestableClass</code> 类本身。</p>
<h3 id="修改原有属性的描述符"><a href="#修改原有属性的描述符" class="headerlink" title="修改原有属性的描述符"></a>修改原有属性的描述符</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">@seal</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  sayHi() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">seal</span>(<span class="params">constructor</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> descriptor = <span class="built_in">Object</span>.getOwnPropertyDescriptor(constructor.prototype, &#x27;sayHi&#x27;)</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(constructor.prototype, &#x27;sayHi&#x27;, &#123;</span><br><span class="line">    ...descriptor,</span><br><span class="line">    writable: <span class="literal">false</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.sayHi = <span class="number">1</span> <span class="comment">// 无效</span></span><br></pre></td></tr></table></figure>

<h3 id="多个装饰器同时使用"><a href="#多个装饰器同时使用" class="headerlink" title="多个装饰器同时使用"></a>多个装饰器同时使用</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">@decorator1</span><br><span class="line">@decorator2</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span></span>&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行的顺序为<code>decorator2</code> -&gt; <code>decorator1</code>，离<code>class</code>定义最近的先执行。</p>
<h2 id="Decorator在class属性上使用"><a href="#Decorator在class属性上使用" class="headerlink" title="@Decorator在class属性上使用"></a>@Decorator在class属性上使用</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readonly</span>(<span class="params">target, key, descriptor</span>) </span>&#123;</span><br><span class="line">  descriptor.writable = <span class="literal">false</span></span><br><span class="line">  <span class="keyword">return</span> descriptor</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> </span>&#123;</span><br><span class="line">  @readonly</span><br><span class="line">  bark () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;wang!wang!&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> dog. = <span class="keyword">new</span> Dog()</span><br><span class="line">dog.bark = <span class="string">&#x27;bark! bark!&#x27;</span></span><br><span class="line"><span class="comment">// Cannot assign to read only property &#x27;bark&#x27; of [object Object]</span></span><br></pre></td></tr></table></figure>

<p><code>decorator</code> 就是一个普通函数，只不过它接收 3 个参数，与<code>Object.defineProperty</code> 一致。具体在这里，我们就是把 <code>descriptor</code> 的<code>writable</code> 字段设为 <code>false</code>。然后把 <code>readonly </code>作用到<code> bark</code> 方法上。</p>
<p>它的具体操作步骤是怎么运行的呢？这里给出它转换成ES5之后的代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 步骤 1</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dog</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 步骤 2</span></span><br><span class="line"><span class="keyword">let</span> descriptor = &#123;</span><br><span class="line">  value: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="string">&#x27;wang!wang!&#x27;</span> &#125;,</span><br><span class="line">  enumerable: <span class="literal">false</span>,</span><br><span class="line">  configurable: <span class="literal">true</span>,</span><br><span class="line">  writable: <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">descriptor = readonly(Dog.prototype, <span class="string">&#x27;bark&#x27;</span>, descriptor) || descriptor</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(Dog.prototype, <span class="string">&#x27;bark&#x27;</span>, descriptor)</span><br></pre></td></tr></table></figure>

<p>所以说呢，ES7 的 <code>decorator</code>，作用就是返回一个新的 <code>descriptor</code>，并把这个新返回的 <code>descriptor</code> 应用到目标属性上。</p>
<h2 id="使用闭包来实现mixin"><a href="#使用闭包来实现mixin" class="headerlink" title="使用闭包来实现mixin"></a>使用闭包来实现mixin</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123; say() &#123; <span class="keyword">return</span> <span class="number">1</span> &#125; &#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123; hi() &#123; <span class="keyword">return</span> <span class="number">2</span> &#125; &#125;</span><br><span class="line"></span><br><span class="line">@mixin(A, B)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mixin</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">constructor</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> arg <span class="keyword">of</span> args) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> <span class="built_in">Object</span>.getOwnPropertyNames(arg.prototype)) &#123;</span><br><span class="line">                <span class="comment">// 跳过构造函数</span></span><br><span class="line">                <span class="keyword">if</span> (key === <span class="string">&#x27;constructor&#x27;</span>) <span class="keyword">continue</span> </span><br><span class="line">                <span class="built_in">Object</span>.defineProperty(constructor.prototype, key, <span class="built_in">Object</span>.getOwnPropertyDescriptor(arg.prototype, key))</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> c = <span class="keyword">new</span> C()</span><br><span class="line"><span class="built_in">console</span>.log(c.say(), c.hi()) <span class="comment">// 1, 2</span></span><br></pre></td></tr></table></figure>

<p>除此之外，<a href="https://link.zhihu.com/?target=http://raganwald.com/">raganwald</a>（<em>JavaScript Allongé, the “Six” Edition</em> 的作者）写了<a href="https://link.zhihu.com/?target=http://raganwald.com/2015/06/26/decorators-in-es7.html">一篇文章</a>介绍如何使用 decorator 来实现 mixin。这对框架和类库作者来说是一个重磅好消息。</p>
<h2 id="Decorator-有啥用"><a href="#Decorator-有啥用" class="headerlink" title="@Decorator 有啥用"></a>@Decorator 有啥用</h2><p>在 Python 里，<code>decorator</code> 的作用非常丰富，比如可以定义一些快捷方式（如@staticmethod，@classmethod 之类），比如构建后端服务Flask框架中的路由蓝图等等。</p>
<p>而在JS中呢，最为常见的就是后端服务中nestjs框架的应用，同时配合Typescript会有很多有趣的操作。也有很多人已经做好了非常方便的工具库，使用时一个<code>@</code>符就能省去很多代码。</p>
<p>虽然近年来它的相关提案内容更改极大，但还是很具有学习价值的。就这样，溜了溜了～</p>
]]></content>
  </entry>
  <entry>
    <title>vue 自定义组件v-model双向绑定和父子组件同步通信</title>
    <url>/2020/10/17/%E8%87%AA%E5%AE%9A%E4%B9%89v-model/</url>
    <content><![CDATA[<h1 id="vue-自定义组件v-model双向绑定和父子组件同步通信"><a href="#vue-自定义组件v-model双向绑定和父子组件同步通信" class="headerlink" title="vue 自定义组件v-model双向绑定和父子组件同步通信"></a>vue 自定义组件v-model双向绑定和父子组件同步通信</h1><h2 id="原因嘛。。"><a href="#原因嘛。。" class="headerlink" title="原因嘛。。"></a>原因嘛。。</h2><p>就是看vue教程时候没看懂，我直接阿巴阿巴，<a href="%5Bhttps://cn.vuejs.org/v2/guide/components-custom-events.html#%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BB%84%E4%BB%B6%E7%9A%84-v-model%5D(https://cn.vuejs.org/v2/guide/components-custom-events.html#%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BB%84%E4%BB%B6%E7%9A%84-v-model)">这个</a></p>
<p>然后搜了下，转眼一看自己又像个憨批了🤣</p>
<a id="more"></a>

<h2 id="简单介绍下"><a href="#简单介绍下" class="headerlink" title="简单介绍下"></a>简单介绍下</h2><p><code>v-model</code>指令通常用在与用户交互填写相关信息上，比如在表单 <code>&lt;input&gt;</code>、<code>&lt;textarea&gt;</code> 及 <code>&lt;select&gt;</code> 元素上创建双向数据绑定。</p>
<p>本质上就是绑定prop的语法糖：绑定数据，而后触发事件，更新数据。</p>
<blockquote>
<p>为什么会有自定义model这样的操作呢，是因为，<code>v-model</code>在默认的情况下，绑定的prop是value，触发的事件是input，具体来讲就是</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// v-model</span></span><br><span class="line">&lt;custom-input v-model=<span class="string">&quot;test&quot;</span>&gt;&lt;/custom-input&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 本质上</span></span><br><span class="line">&lt;custom-input :value=<span class="string">&quot;test&quot;</span> @input=<span class="string">&quot;value =&gt; test = value&quot;</span>&gt;<span class="xml"><span class="tag">&lt;<span class="name">custom-input</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>所以嘞，一个自定义的<code>v-model</code>组件中就是自定义接受的数据是啥，自定义触发的事件是啥。</p>
</blockquote>
<p>vue原文：</p>
<blockquote>
<p><a href="https://cn.vuejs.org/v2/guide/components-custom-events.html#%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BB%84%E4%BB%B6%E7%9A%84-v-model">自定义组件的 <code>v-model</code></a></p>
<p>​    2.2.0+ 新增</p>
<p>一个组件上的 <code>v-model</code> 默认会利用名为 <code>value</code> 的 prop 和名为 <code>input</code> 的事件，但是像单选框、复选框等类型的输入控件可能会将 <code>value</code> attribute 用于<a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/checkbox#Value">不同的目的</a>。</p>
</blockquote>
<h2 id="来了来了，实操讲解了（v-model通信）"><a href="#来了来了，实操讲解了（v-model通信）" class="headerlink" title="来了来了，实操讲解了（v-model通信）"></a>来了来了，实操讲解了（<code>v-model</code>通信）</h2><h3 id="写法一（推荐）"><a href="#写法一（推荐）" class="headerlink" title="写法一（推荐）"></a>写法一（推荐）</h3><p>这里就解释下vue官方教程中的例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 自定义的v-model组件</span></span><br><span class="line">Vue.component(<span class="string">&#x27;base-checkbox&#x27;</span>, &#123;</span><br><span class="line">  model: &#123;</span><br><span class="line">    prop: <span class="string">&#x27;checked&#x27;</span>, <span class="comment">// 这个prop： checked，就是自定义的prop。是在该组件被调用时用v-model获取到的值，即下面调用该组件时用v-model传入的lovingvue, 可以这样理解，该组件将外面v-model传入的值用checked这个prop来接收。</span></span><br><span class="line">    event: <span class="string">&#x27;change&#x27;</span>  <span class="comment">// 这个event： change，就是自定义的触发事件。触发该事件时，更新的值就会自动更新给v-model绑定的值。用下面使用的实例来说，就是，在子组件base-checkbox触发自身的change事件时，这时会执行$emit(&#x27;change&#x27;, $event.target.checked)， 那么就是说触发了父组件的change事件，此时携带的参数， $event.target.checked会自动赋值给v-model所绑定的lovingvue这个变量，实现数据更新。</span></span><br><span class="line">  &#125;,</span><br><span class="line">  props: &#123;</span><br><span class="line">    checked: <span class="built_in">Boolean</span> <span class="comment">// 上面的model对象是对v-model的自定义，但是仍然需要在props中声明 checked 这个 prop。</span></span><br><span class="line">  &#125;,</span><br><span class="line">  template: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;input</span></span><br><span class="line"><span class="string">      type=&quot;checkbox&quot;</span></span><br><span class="line"><span class="string">      v-bind:checked=&quot;checked&quot; // 将prop: checked绑定到 input标签上的attr: checked上</span></span><br><span class="line"><span class="string">      v-on:change=&quot;$emit(&#x27;change&#x27;, $event.target.checked)&quot; // change事件触发时，触发父组件自定义的change事件，并传入更新后的值</span></span><br><span class="line"><span class="string">    &gt;</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用自定义组件时</span></span><br><span class="line">&lt;base-checkbox v-model=<span class="string">&quot;lovingVue&quot;</span>&gt;&lt;/base-checkbox&gt;</span><br></pre></td></tr></table></figure>

<p>这个例子中可能各种prop与attr名称一样，看的有点迷糊，我下面就改一下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 自定义的v-model组件</span></span><br><span class="line">Vue.component(<span class="string">&#x27;base-checkbox&#x27;</span>, &#123;</span><br><span class="line">  model: &#123;</span><br><span class="line">    prop: <span class="string">&#x27;propChecked&#x27;</span>, <span class="comment">// 自定义的prop</span></span><br><span class="line">    event: <span class="string">&#x27;emit-change-event&#x27;</span> <span class="comment">// 自定义的v-model绑定触发事件</span></span><br><span class="line">  &#125;,</span><br><span class="line">  props: &#123;</span><br><span class="line">    propChecked: <span class="built_in">Boolean</span> <span class="comment">// 仍需要声明接受的prop</span></span><br><span class="line">  &#125;,</span><br><span class="line">  template: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;input</span></span><br><span class="line"><span class="string">      type=&quot;checkbox&quot;</span></span><br><span class="line"><span class="string">      v-bind:checked=&quot;propChecked&quot;</span></span><br><span class="line"><span class="string">      v-on:change=&quot;$emit(&#x27;emit-change-event&#x27;, $event.target.checked)&quot; // 这里触发父组件的v-model绑定的事件</span></span><br><span class="line"><span class="string">    &gt;</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用自定义组件时</span></span><br><span class="line">&lt;base-checkbox v-model=<span class="string">&quot;lovingVue&quot;</span>&gt;&lt;/base-checkbox&gt;</span><br></pre></td></tr></table></figure>

<h3 id="写法二"><a href="#写法二" class="headerlink" title="写法二"></a>写法二</h3><p>之前提到<code>v-model</code>默认绑定的prop是value，默认绑定的触发事件是input。</p>
<p>所以写法二也就很明了咯。</p>
<p>这里正好可以对比下，就改写上面vue官方的例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 自定义的v-model组件</span></span><br><span class="line">Vue.component(<span class="string">&#x27;base-checkbox&#x27;</span>, &#123;</span><br><span class="line">  props: &#123;</span><br><span class="line">    value: &#123; <span class="comment">// 这里显式地用默认的propvalue来接收</span></span><br><span class="line">		<span class="keyword">default</span>: <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  template: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;input</span></span><br><span class="line"><span class="string">      type=&quot;checkbox&quot;</span></span><br><span class="line"><span class="string">      v-bind:checked=&quot;value&quot;</span></span><br><span class="line"><span class="string">      v-on:change=&quot;$emit(&#x27;input&#x27;, $event.target.checked)&quot; // 这里触发默认绑定事件input</span></span><br><span class="line"><span class="string">    &gt;</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用自定义组件时</span></span><br><span class="line">&lt;base-checkbox v-model=<span class="string">&quot;lovingVue&quot;</span>&gt;&lt;/base-checkbox&gt;</span><br></pre></td></tr></table></figure>



<p>建议使用写法一，不然怎么叫自定义嘛，对吧😁</p>
<p>以上便是小生对此一拙见。</p>
<p>ref： <a href="http://www.dongxiaofeng.com/2019/02/18/vue-%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BB%84%E4%BB%B6v-model%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%E5%92%8C%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6%E5%90%8C%E6%AD%A5%E9%80%9A%E4%BF%A1/">http://www.dongxiaofeng.com/2019/02/18/vue-%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BB%84%E4%BB%B6v-model%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%E5%92%8C%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6%E5%90%8C%E6%AD%A5%E9%80%9A%E4%BF%A1/</a></p>
]]></content>
  </entry>
  <entry>
    <title>入坑博客咯ε=( o｀ω′)ノ</title>
    <url>/2020/10/17/hello-world/</url>
    <content><![CDATA[<h2 id="要不就随手记下入坑过程吧😁"><a href="#要不就随手记下入坑过程吧😁" class="headerlink" title="要不就随手记下入坑过程吧😁"></a>要不就随手记下入坑过程吧😁</h2><ol>
<li><p>首先呢，npm，git啥的你总该要装吧，记得换成淘宝源，要不然可能贼慢(虽然俺没试过(+_+))。</p>
</li>
<li><p>这里用的是hexo框架，所以就直接去<a href="https://hexo.io/">官网</a>找吧<br>在随便一个文件夹中去，可以用<code>git bash</code>，也可以用win的cmd(这里提醒下：最好用管理员版（win+x就能看见)）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br><span class="line">hexo init blog</span><br><span class="line">cd blog</span><br><span class="line">npm install</span><br><span class="line">hexo server</span><br></pre></td></tr></table></figure>

<p>有个坑有点烦的，在<code>hexo init blog</code>的时候会有对远程仓库的cloning，会很慢，之前一直卡在那儿一直以为是我这里代理问题，结果。。。。昂，对，我多等了一会儿就行了，之前使用<code>git bash</code>的结果好像有报错…..搞忘了， 算了( &amp; _ &amp; )你不在意的吧</p>
</li>
<li><p>再就是去github建一个仓库命名为<code>YourGithubName.github.io</code>， 比如我这个就叫<code>fireworkHy.github.io</code></p>
</li>
<li><p>再回来，去本地博客文件夹中找到<code>_config.yml</code>这个配置文件，翻到它的最下面：<br>找到deploy，这个是由hexo提供的一键部署的配置地方，加上这些：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: https:&#x2F;&#x2F;github.com&#x2F;fireworkHy&#x2F;fireworkHy.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>

<p>默认是也会放在master分支上，但是最好显式配置下。</p>
</li>
<li><p>最后就是部署了, 回到命令行中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo d</span><br></pre></td></tr></table></figure>

<p>就没了，昂，就这样，别觉得太难哟，一步到位</p>
</li>
</ol>
<blockquote>
<p>测试之后发现访问太慢了，翻墙的话还好，如果图片多了，资源拥挤了，访问可能会很慢，虽然。。。我感觉开发的应该都翻墙的吧hhh，不会还有人不会翻墙吧，不会吧不会吧🧐</p>
<p>所以准备在码云上部署博客，这两边都会更新的，码云的话，站点在国内，一定会很快😋</p>
</blockquote>
<h2 id="下面给出一些可能常用的hexo命令🎈"><a href="#下面给出一些可能常用的hexo命令🎈" class="headerlink" title="下面给出一些可能常用的hexo命令🎈"></a>下面给出一些可能常用的hexo命令🎈</h2><h3 id="建立新博文"><a href="#建立新博文" class="headerlink" title="建立新博文"></a>建立新博文</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>详情戳这儿👉: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="本地跑服务"><a href="#本地跑服务" class="headerlink" title="本地跑服务"></a>本地跑服务</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>戳这儿戳这儿👉: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="生成静态文件"><a href="#生成静态文件" class="headerlink" title="生成静态文件"></a>生成静态文件</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>当然还是戳这儿咯🙃: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="部署到远程站点"><a href="#部署到远程站点" class="headerlink" title="部署到远程站点"></a>部署到远程站点</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>不多1313👉: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>重拾JS(一)--浅谈new和this</title>
    <url>/2020/10/28/%E9%87%8D%E6%8B%BEJS(%E4%B8%80)/</url>
    <content><![CDATA[<h1 id="重拾JS-一-–浅谈new和this"><a href="#重拾JS-一-–浅谈new和this" class="headerlink" title="重拾JS(一)–浅谈new和this"></a>重拾JS(一)–浅谈new和this</h1><h2 id="new操作符"><a href="#new操作符" class="headerlink" title="new操作符"></a><code>new</code>操作符</h2><p>我们在学习编程时应该都会接触到OOP编程范式，而对于JS这门语言来说，JS是一门多范式编程语言，命令式、函数式以及面向对象。</p>
<p>而new在JS中的作用就是：执行构造函数，并返回一个实例对象，这一部分就与面向对象相关了。</p>
<h3 id="面向对象的对象是啥嘞？🤔"><a href="#面向对象的对象是啥嘞？🤔" class="headerlink" title="面向对象的对象是啥嘞？🤔"></a>面向对象的对象是啥嘞？🤔</h3><p>对象—&gt;Object，不同于JS中的数据类型Object，作为OOP编程范式中的主体，我们可以从两个层次去理解：</p>
<ul>
<li><p><strong>对象是某实物的抽象化单元。</strong></p>
<p>一个人、一棵树、一间房子，均可以看作是一个对象，当我们把它抽象出来，例如它仅仅是棵树，它的树龄，它的科属均属于这个对象的属性，而多棵树呢就是多个树对象罢了。</p>
</li>
<li><p><strong>对象是个包装了属性(property)和方法(method)的盒子。</strong></p>
<p>我们可以把任意一个事物抽象成它的状态(property)和行为(method)的集合。例如，还将上述的树作例子吧，它的树龄就是它的属性，它的科属也是它的属性，而它可以进行光合作用这一行为的能力就是它的方法，它进行呼吸作用这一行为的能力也是它的方法。   一个对象中，属性可以有多个，方法也一样可以有多个。</p>
</li>
</ul>
<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>要想实行OOP，少不了对象嘛。对象作为一个实物的抽象单元，在JS中需要通过执行构造函数(constructor)来生成对象，这里不做过多介绍，仅说明两个特点：</p>
<blockquote>
<ul>
<li>函数体内部可使用<code>this</code>关键字，指向函数生成的对象实例。</li>
<li>生成对象必须使用<code>new</code>命令</li>
</ul>
</blockquote>
<h3 id="没有对象？new一个！☺️"><a href="#没有对象？new一个！☺️" class="headerlink" title="没有对象？new一个！☺️"></a>没有对象？<code>new</code>一个！☺️</h3><p>生成一个对象<code>new</code>一个就行了：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// constructor function</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">People</span> (<span class="params">name, age</span>) </span>&#123;</span><br><span class="line"><span class="meta">  &#x27;use strict&#x27;</span>;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">  <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// create object instance</span></span><br><span class="line"><span class="keyword">const</span> xingjiejie = <span class="keyword">new</span> People(<span class="string">&#x27;xingjiejie&#x27;</span>, <span class="number">18</span>)</span><br></pre></td></tr></table></figure>

<p>小提一句：<code>new</code>命令本身就可以执行构造函数，就是说函数后面可以不带括号，不过推荐加上括号。</p>
<p>有一个小问题，就是既然这个构造函数跟平常的函数没什么区别，那么不使用<code>new</code>会怎么样呢，这个时候并不会生成实例对象，而且，如果构造函数中有赋给this的属性话，这些属性会赋给全局对象上，这个原因放在后面讲。为了避免导致这样的问题发生，可以在函数体中加上    ‘use strict’    ，运行时不用new调用便会报错。</p>
<h3 id="new到底是个啥？😁"><a href="#new到底是个啥？😁" class="headerlink" title="new到底是个啥？😁"></a><code>new</code>到底是个啥？😁</h3><p><strong>下面来介绍下<code>new</code>命令的原理：</strong></p>
<p>他依次执行以下步骤：</p>
<ol>
<li>创建一个空对象，作为将要返回的对象实例。</li>
<li>改变空对象原型为构造函数的原型：<code>prototype</code></li>
<li>将this指针指向该空对象。</li>
<li>执行构造函数。</li>
</ol>
<p>也就是说，构造函数中的this，其实指的是另外重新生成的空对象，可不要以为是那个函数哟👅</p>
<p>注意一点，如果构造函数内部有<code>return</code>语句，<strong>而且<code>return</code>了一个对象</strong>，那么<code>new</code>操作后创建的对象是这个<code>return</code>返回的对象，而不是内部重新创建的空对象。否则仍返回<code>this</code>对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">  <span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">(<span class="keyword">new</span> Animal(<span class="string">&#x27;dog&#x27;</span>) === <span class="string">&#x27;dog&#x27;</span>) <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Tree</span>(<span class="params">height</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.height = height;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    height: <span class="number">1988</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">(<span class="keyword">new</span> Tree(<span class="number">2001</span>)).height === <span class="number">1988</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>下面简单的手写一个<code>new</code>的函数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_new</span> (<span class="params">constructor, ...params</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 创建空对象将其原型指向构造函数的显式原型</span></span><br><span class="line">  <span class="keyword">const</span> ctx = <span class="built_in">Object</span>.create(constructor.prototype);</span><br><span class="line">  <span class="comment">// 执行构造函数</span></span><br><span class="line">  <span class="keyword">const</span> res = constructor.apply(ctx, params);</span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">typeof</span> res === <span class="string">&#x27;object&#x27;</span> &amp;&amp; res != <span class="literal">null</span>) ? res : ctx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="this关键字"><a href="#this关键字" class="headerlink" title="this关键字"></a><code>this</code>关键字</h2><blockquote>
<p>这个<code>this</code>鸭，作为JS基础的三座大山之一，可以说道的东西还是不少的，这里本人做一些浅析，如有错误或不足，欢迎指正😊</p>
</blockquote>
<p>JS中<code>this</code>的问题还是很大的，如果在复杂环境中不能做好对<code>this</code>的处理，很容易出现混乱的情况，造成难以预料的后果，为了解决这一问题，TS中也对<code>this</code>进行了相应的类型标定，当然这都是后话了。</p>
<h3 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h3><p>上面的JS的OOP实现中提到<code>this</code>用在构造函数中表示的是新创建的空对象。不仅如此，<code>this</code>的使用场景还是很多的。但它的一个重要特点就是： 会返回一个对象Object。</p>
<p><code>this</code>它表示的是什么意思呢？简单来讲就是字面意思hh： ‘这个，这里，这’  ，表示它所在的地方是哪里，<strong>在JS中就是说它所在的对象是什么，表示为它所在的对象。</strong>在它被创造出来之初的含义便是如此，至于后来冒出来的各种<code>this</code>相关的有违逻辑的问题恐怕也是最开始作者未曾想到的吧，毕竟JS也只不过是15天创造出来的呢😅</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  name: <span class="string">&#x27;张三&#x27;</span>,</span><br><span class="line">  desc: <span class="string">&#x27;法外狂徒&#x27;</span>,</span><br><span class="line">  describe: <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.name + <span class="string">&#x27;是&#x27;</span> + <span class="built_in">this</span>.desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">person.describe() <span class="comment">// 张三是法外狂徒</span></span><br></pre></td></tr></table></figure>



<p>这里的实例暂时还是很容易理解的，后面的一些略骚的操作就要来了～</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = &#123;</span><br><span class="line">  desc: <span class="string">&#x27;I\&#x27;m a&#x27;</span>,</span><br><span class="line">  say: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.name</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> b = &#123;</span><br><span class="line">  desc: <span class="string">&#x27;I\&#x27;m b&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">b.say = a.say;</span><br><span class="line">b.say(); <span class="comment">// I&#x27;m b</span></span><br></pre></td></tr></table></figure>

<p>这里把a 的<code>say</code>方法赋给了b， 通过<code>b.say()</code>这样的方法去调用<code>say</code>方法，最终返回的结果中的<code>this</code>变成了 b 这个对象。也就是说，JS中，对象的属性赋给另一个对象的时候，那这个属性所在的对象也会随之变化，突出表现为<code>this</code>的指向问题，<code>this</code>的指向是会变化的。</p>
<p><strong>谨记一点，<code>this</code>     的意思：它所在的对象是啥。</strong></p>
<h3 id="this的实质问题"><a href="#this的实质问题" class="headerlink" title="this的实质问题"></a><code>this</code>的实质问题</h3><p>通过查阅资料：有如下说明</p>
<p>JS两种之所以有<code>this</code>的设计，跟内存中的数据结构有关。</p>
<p>JS中一切皆对象，执行代码时，比如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  num : <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建对象时，JS引擎会在内存中创建一个对象，同时将该对象的地址作为原始类型的值赋给变量obj，如需访问obj，引擎会通过obj所存储的地址去访问那个对象。</p>
<p>而且对于对象的每一个属性，每个属性都是一个 属性描述性对象 。</p>
<p>如下代码表示obj对象可能会直观一点：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  num : &#123;</span><br><span class="line">    value: <span class="number">0</span>,</span><br><span class="line">    enumerable: <span class="literal">true</span>,</span><br><span class="line">    configurable: <span class="literal">true</span>,</span><br><span class="line">    writable: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当对象的属性是个函数的时候，函数也是对象，只是是特殊的对象罢了，那么这个属性的值也是一个地址，访问的时候会根据这个地址去调用函数。</p>
<p>那么函数作为一个单独的对象，它就意味着它可以通过这个地址在不同的上下文(<code>context</code>)中运行。</p>
<p>那么当调用的环境很多很复杂的时候，函数如何去判断自己运行时所处的环境呢，<code>this</code>就是这样来的，用来表示函数运行时所处的上下文(<code>context</code>)。</p>
<h3 id="this运行时环境"><a href="#this运行时环境" class="headerlink" title="this运行时环境"></a><code>this</code>运行时环境</h3><h4 id="全局环境"><a href="#全局环境" class="headerlink" title="全局环境"></a>全局环境</h4><p>这里简单点可以分<code>浏览器</code>环境和<code>node</code>环境，<code>浏览器</code>中全局对象为<code>window</code>， <code>node</code>中全对象为<code>global。</code></p>
<p>ps. 这里应该作者尚未修补的一个小坑。</p>
<h4 id="构造函数-1"><a href="#构造函数-1" class="headerlink" title="构造函数"></a>构造函数</h4><p><code>this</code>指的是创建的空对象Object。</p>
<h4 id="对象的方法"><a href="#对象的方法" class="headerlink" title="对象的方法"></a>对象的方法</h4><p><code>this</code>指向是方法运行时所在的对象。稍微注意下方法改变环境时，<code>this</code>也会改变。</p>
<p>下面给些<code>this</code>指向改变的情况：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 均在浏览器环境中运行</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  _this: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  	<span class="built_in">console</span>.log(<span class="built_in">this</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">(obj._this = obj._this)() <span class="comment">// Window</span></span><br><span class="line"></span><br><span class="line">(<span class="literal">false</span> || obj._this)() <span class="comment">// Window</span></span><br><span class="line"></span><br><span class="line">(<span class="number">1</span>, obj._this)() <span class="comment">// Window</span></span><br></pre></td></tr></table></figure>

<p>上述代码中，当调用<code>obj._this</code>这个方法的时候它的环境已经变成了全局环境。</p>
<p>可以这样认为：正常调用<code>obj._this()</code>是从全局找到obj的地址，再从obj的地址去找<code>_this</code>方法的地址，那么它的运行环境就是obj的地址，而上述代码例子中是直接从全局出发去找<code>_this</code>的地址，那么它们的运行环境是全局环境。</p>
<p>等同于下面的代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>)</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line">(<span class="literal">false</span> || <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>)</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line">(<span class="number">1</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>)</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>



<p>还有可能出现对象嵌套的情况：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> o1 = &#123;</span><br><span class="line">  num: <span class="number">1</span>,</span><br><span class="line">  o2: &#123;</span><br><span class="line">    say: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="built_in">this</span>.num)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">o1.o2.say() <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<p>上述代码中，<code>this</code>所在的方法在对象<code>o2</code>中，所以打印的结果是undefined。</p>
<p>等效于：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> o2 = &#123;</span><br><span class="line">  say: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.num)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> o1 = &#123;</span><br><span class="line">  num: <span class="number">1</span>,</span><br><span class="line">  o2: o2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果想要达成预期，就要思考怎样去改变这个<code>this</code>的指向。</p>
<h3 id="this的绑定"><a href="#this的绑定" class="headerlink" title="this的绑定"></a><code>this</code>的绑定</h3><p>JavaScript 提供了<code>call</code>、<code>apply</code>、<code>bind</code>这三个方法，来切换/固定<code>this</code>的指向。</p>
<h4 id="Function-prototype-call"><a href="#Function-prototype-call" class="headerlink" title="Function.prototype.call()"></a><code>Function.prototype.call()</code></h4><p><code>call</code>方法可以指定函数内部<code>this</code>的指向，是函数可以在指定的上下文环境中执行。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;&#125;</span><br><span class="line"><span class="keyword">const</span> f = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f() === <span class="built_in">window</span> <span class="comment">// true</span></span><br><span class="line">f.call(obj) === obj <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>很明显，执行<code>call</code>方法时的<code>this</code>改变成了<code>obj</code>这个对象。</p>
<p><code>call</code>方法的第一个参数，应该是一个参数，如果为空、<code>undefined</code>、<code>null</code>，则<code>this</code>指向全局对象。如果为原始类型的值，则<code>this</code>指向该原始类型值的包装对象。</p>
<p><code>call</code>方法后面的参数会依次传给函数的参数列表中。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add.call(<span class="built_in">this</span>, <span class="number">1</span>, <span class="number">2</span>) <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>



<p><code>call</code>方法的一个应用是调用对象的原生方法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line">obj.hasOwnProperty(<span class="string">&#x27;toString&#x27;</span>) <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 覆盖掉继承的 hasOwnProperty 方法</span></span><br><span class="line">obj.hasOwnProperty = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br><span class="line">obj.hasOwnProperty(<span class="string">&#x27;toString&#x27;</span>) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.prototype.hasOwnProperty.call(obj, <span class="string">&#x27;toString&#x27;</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>将<code>obj</code>对象上的<code>hasOwnProperty</code>方法修改之后，直接通过<code>obj    .hasOwnProperty()</code>不会得到应有的结果。而通过<code>call</code>可以去指定<code>this</code>调用原生的<code>Object</code>上的方法。</p>
<h4 id="Function-prototype-apply"><a href="#Function-prototype-apply" class="headerlink" title="Function.prototype.apply()"></a><code>Function.prototype.apply()</code></h4><p>与<code>call</code>基本一致，唯独在它接受的参数列表上与<code>call</code>不同，第一个仍是指定<code>this</code>的指向对象，而第二个参数是一个参数数组。</p>
<p>该参数数组在执行时会解构赋给函数。</p>
<p>如下例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// call</span></span><br><span class="line">add.call(<span class="built_in">this</span>, <span class="number">1</span>,<span class="number">2</span>) <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// apply</span></span><br><span class="line">add.apply(<span class="built_in">this</span>, [<span class="number">1</span>, <span class="number">2</span>]) <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<p>这个特性在<code>rest</code>运算符出现之前就有了很多有趣的玩法，大家可以自行尝试。</p>
<blockquote>
<ul>
<li>找出数组的最大最小值</li>
<li>将数组的空位置为<code>undefined</code></li>
<li>转换类数组对象为数组对象</li>
</ul>
</blockquote>
<h4 id="Function-prototype-bind"><a href="#Function-prototype-bind" class="headerlink" title="Function.prototype.bind()"></a><code>Function.prototype.bind()</code></h4><p><code>bind()</code>方法用于将函数体内的<code>this</code>绑定到某个对象，然后返回一个新函数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> counter1 = &#123;</span><br><span class="line">  count: <span class="number">0</span>,</span><br><span class="line">  increat: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.count++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> counter2 = &#123;</span><br><span class="line">  count: <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> func = counter.increat.bind(counter2);</span><br><span class="line">func();</span><br><span class="line">counter1.count <span class="comment">// 0</span></span><br><span class="line">counter2.count <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>counter1.increat()</code>方法被赋值给变量<code>func</code>。这时必须用<code>bind()</code>方法将<code>increat()</code>内部的<code>this</code>，绑定到<code>counter2</code>，<code>this</code>指向的便是对象<code>counter2</code>，操作的自加操作也是针对<code>counter2.count</code>。</p>
<p><code>bind()</code>还可以接受更多的参数，将这些参数绑定原函数的参数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x * <span class="built_in">this</span>.m + y * <span class="built_in">this</span>.n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  m: <span class="number">1</span>,</span><br><span class="line">  n: <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> newAdd = add.bind(obj, <span class="number">5</span>);</span><br><span class="line">newAdd(<span class="number">5</span>) <span class="comment">// 20</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>bind()</code>方法除了绑定<code>this</code>对象，还将<code>add()</code>函数的第一个参数<code>x</code>绑定成<code>5</code>，然后返回一个新函数<code>newAdd()</code>，这个函数只要再接受一个参数<code>y</code>就能运行了。</p>
<p>是不是很有意思！这就有了更多有趣的玩法，JS很多高级编程都可以通过<code>bind</code>来实现。就当是挖个坑吧，有空再填。</p>
<h2 id="就这样，白白～"><a href="#就这样，白白～" class="headerlink" title="就这样，白白～"></a>就这样，白白～</h2>]]></content>
  </entry>
</search>
